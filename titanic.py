# -*- coding: utf-8 -*-
"""Titanic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bByShLdYOe-mC9LvTQ9VQU58RaFBuugl
"""



"""# Importanto as bibliotecas

"""

!pip install scikit-learn==1.5.0

import pandas as pd
import numpy as np
from pandas import DataFrame
import seaborn as sns
from google.colab import drive
import plotly.express as px
import plotly.graph_objects as go
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier, export_graphviz
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC
import graphviz
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.datasets import load_iris
#from googletrans import Translator
import joblib
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import LabelEncoder
from google.colab import files

"""# Dicionário de daods

1.   Sex = gênero: male (masculino) ou female (feminino)
2.   Age = idade
3.   Pclass - classe do navio (1, 2 ou 3)
4.   Embarked = Porto de embarque (C = Cherbourg, Q = Queenstown, S = Southampton)
5.   Fare = Tarifa paga pelo passageiro
6.   Survived - Se o passageiro sobreviveu (1 = sim, 0 = não)

# Carregando os dados
"""

drive.mount('/content/gdrive/')

data_treino = pd.read_csv("/content/gdrive/My Drive/titanic/train.csv")

data_treino

data_teste = pd.read_csv("/content/gdrive/My Drive/titanic/test.csv")

data_teste

"""# Análise de Dados"""

df_grouped = data_treino.groupby(['Sex', 'Survived'])['PassengerId'].count().reset_index(name='Count')
df_total = data_treino.groupby(['Sex'])['PassengerId'].count().reset_index(name='Total')
df_percentual = pd.merge(df_grouped, df_total, on='Sex', how='left')
df_percentual['Percentual'] = (df_percentual['Count'] / df_percentual['Total']) * 100

fig = px.bar(df_percentual, x="Sex", y="Percentual", color="Survived",
             title='Percentual de Sexo por Sobrevivência',
             labels={'Sex': 'Sexo', 'Percentual': 'Percentual', 'Survived': 'Sobreviveu'})
fig.show()

from scipy.stats import chi2_contingency

# Criando a tabela de contingência
contingency_table = pd.crosstab(data_treino['Sex'], data_treino['Survived'])

# Realizando o teste de qui-quadrado
chi2, p, dof, expected = chi2_contingency(contingency_table)

# Imprimindo os resultados
print(f"Valor do qui-quadrado: {chi2}")
print(f"Valor-p: {p}")
print(f"Graus de liberdade: {dof}")
print("Tabela de frequências esperadas:")
print(expected)

# Interpretando o resultado
alpha = 0.05  # Nível de significância
if p < alpha:
    print("Rejeitamos a hipótese nula. Há uma associação significativa entre Sexo e Sobrevivência.")
else:
    print("Aceitamos a hipótese nula. Não há evidências suficientes para sugerir uma associação entre Sexo e Sobrevivência.")

df_grouped = data_treino.groupby(['Pclass', 'Survived'])['PassengerId'].count().reset_index(name='Count')
df_total = data_treino.groupby(['Pclass'])['PassengerId'].count().reset_index(name='Total')
df_percentual = pd.merge(df_grouped, df_total, on='Pclass', how='left')
df_percentual['Percentual'] = (df_percentual['Count'] / df_percentual['Total']) * 100

fig = px.bar(df_percentual, x="Pclass", y="Percentual", color="Survived",
             title='Percentual de Pclass por Sobrevivência',
             labels={'Pclass': 'Classe', 'Percentual': 'Percentual', 'Survived': 'Sobreviveu'})
fig.show()

# Criando a tabela de contingência
contingency_table = pd.crosstab(data_treino['Pclass'], data_treino['Survived'])

# Realizando o teste de qui-quadrado
from scipy.stats import chi2_contingency
chi2, p, dof, expected = chi2_contingency(contingency_table)

# Imprimindo os resultados
print(f"Valor do qui-quadrado: {chi2}")
print(f"Valor-p: {p}")
print(f"Graus de liberdade: {dof}")
print("Tabela de frequências esperadas:")
print(expected)

# Interpretando o resultado
alpha = 0.05  # Nível de significância
if p < alpha:
    print("Rejeitamos a hipótese nula. Há uma associação significativa entre Classe e Sobrevivência.")
else:
    print("Aceitamos a hipótese nula. Não há evidências suficientes para sugerir uma associação entre Classe e Sobrevivência.")

df_grouped = data_treino.groupby(['Embarked', 'Survived'])['PassengerId'].count().reset_index(name='Count')
df_total = data_treino.groupby(['Embarked'])['PassengerId'].count().reset_index(name='Total')
df_percentual = pd.merge(df_grouped, df_total, on='Embarked', how='left')
df_percentual['Percentual'] = (df_percentual['Count'] / df_percentual['Total']) * 100

fig = px.bar(df_percentual, x="Embarked", y="Percentual", color="Survived",
             title='Percentual de Embarked por Sobrevivência',
             labels={'Embarked': 'Porto de embarque', 'Percentual': 'Percentual', 'Survived': 'Sobreviveu'})
fig.show()

from scipy.stats import chi2_contingency

# Criando a tabela de contingência
contingency_table = pd.crosstab(data_treino['Embarked'], data_treino['Survived'])

# Realizando o teste de qui-quadrado
chi2, p, dof, expected = chi2_contingency(contingency_table)

# Imprimindo os resultados
print(f"Valor do qui-quadrado: {chi2}")
print(f"Valor-p: {p}")
print(f"Graus de liberdade: {dof}")
print("Tabela de frequências esperadas:")
print(expected)

# Interpretando o resultado
alpha = 0.05  # Nível de significância
if p < alpha:
    print("Rejeitamos a hipótese nula. Há uma associação significativa entre Porto de Embarque e Sobrevivência.")
else:
    print("Aceitamos a hipótese nula. Não há evidências suficientes para sugerir uma associação entre Porto de Embarque e Sobrevivência.")

# Agrupando os dados por Pclass e Embarked e contando os passageiros
df_grouped = data_treino.groupby(['Pclass', 'Embarked'])['PassengerId'].count().reset_index(name='Count')

# Criando o gráfico de barras
fig = px.bar(df_grouped, x="Pclass", y="Count", color="Embarked",
             title='Contagem de Passageiros por Classe e Porto de Embarque',
             labels={'Pclass': 'Classe', 'Count': 'Contagem de Passageiros', 'Embarked': 'Porto de Embarque'})

# Exibindo o gráfico
fig.show()

# Agrupando os dados por Embarked e Pclass e contando os passageiros
df_grouped = data_treino.groupby(['Embarked', 'Pclass'])['PassengerId'].count().reset_index(name='Count')

# Calculando o total de passageiros por Embarked
df_total = data_treino.groupby(['Embarked'])['PassengerId'].count().reset_index(name='Total')

# Unindo os DataFrames para calcular o percentual
df_percentual = pd.merge(df_grouped, df_total, on='Embarked', how='left')
df_percentual['Percentual'] = (df_percentual['Count'] / df_percentual['Total']) * 100

# Criando o gráfico de barras
fig = px.bar(df_percentual, x="Embarked", y="Percentual", color="Pclass",
             title='Percentual de Pclass por Embarked',
             labels={'Embarked': 'Porto de Embarque', 'Percentual': 'Percentual', 'Pclass': 'Classe'})

# Exibindo o gráfico
fig.show()

# Boxplot de Age por Survived
plt.figure(figsize=(8, 6))
sns.boxplot(x='Survived', y='Age', data=data_treino)
plt.title('Distribuição da Idade por Sobrevivência')
plt.xlabel('Sobreviveu (0 = Não, 1 = Sim)')
plt.ylabel('Idade')
plt.show()

# Boxplot de Age por Survived
plt.figure(figsize=(8, 6))
sns.boxplot(x='Survived', y='Fare', data=data_treino)
plt.title('Distribuição da Tarifa por Sobrevivência')
plt.xlabel('Sobreviveu (0 = Não, 1 = Sim)')
plt.ylabel('Tarifa')
plt.show()

# Calculando os limites para outliers
Q1 = data_treino['Fare'].quantile(0.25)
Q3 = data_treino['Fare'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Removendo os outliers
data_treino_sem_outliers = data_treino[(data_treino['Fare'] >= lower_bound) & (data_treino['Fare'] <= upper_bound)]

# Boxplot de Age por Survived
plt.figure(figsize=(8, 6))
sns.boxplot(x='Survived', y='Fare', data=data_treino_sem_outliers)
plt.title('Distribuição da Tarifa por Sobrevivência')
plt.xlabel('Sobreviveu (0 = Não, 1 = Sim)')
plt.ylabel('Tarifa')
plt.show()

"""# Machine Learning"""

data_modelo = data_treino[[ 'Survived', 'Pclass', 'Sex', 'Age', 'Fare', 'Embarked']]

categorical_columns = ['Sex', 'Embarked']
numerical_columns = ['Pclass', 'Age', 'Fare']

le = LabelEncoder()

# Transformando e salvando os encoders
data_modelo['Sex'] = le.fit_transform(data_modelo['Sex'])
joblib.dump(le, 'label_encoder_Sex.pkl')
files.download(f'label_encoder_Sex.pkl')


data_modelo['Embarked'] = le.fit_transform(data_modelo['Embarked'])
joblib.dump(le, 'label_encoder_Embarked.pkl')
files.download(f'label_encoder_Embarked.pkl')

data_modelo

from sklearn.preprocessing import LabelEncoder
import joblib
from google.colab import files

categorical_columns_for_transformer = ['Sex', 'Embarked']

preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numerical_columns),
        ('cat', 'passthrough', categorical_columns_for_transformer)
    ]
)

pipeline = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('classifier', HistGradientBoostingClassifier())
])

"""# DOWNLOAD"""

X = data_modelo[numerical_columns + categorical_columns]
y = data_modelo['Survived']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

pipeline.fit(X_train , y_train)

# Salvar o pipeline inteiro
joblib.dump(pipeline, 'modelo_titanic.pkl')
files.download('modelo_titanic.pkl')

y_pred = pipeline.predict(X_test)

# Avalie o desempenho do modelo
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)
print("Model accuracy:", accuracy)
print("Report:\n", report)